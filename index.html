<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Démo SPC Payment Request</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    h1, h2 { color: #333; }
    button { padding: 0.5em 1em; margin: 0.5em 0; }
    #logContainer details { margin-top: 1em; }
    #log { white-space: pre-wrap; background: #f9f9f9; padding: 1em; border: 1px solid #ddd; max-height: 200px; overflow-y: auto; }
  </style>
</head>
<body>
  <h1>Démo Secure Payment Confirmation (SPC)</h1>

  <section id="enrolment">
    <h2>Phase d'enrôlement</h2>
    <button id="btnEnrol">Enrôler le dispositif</button>
  </section>

  <section id="payment">
    <h2>Phase de paiement</h2>
    <button id="btnCheck">Vérifier la possibilité SPC</button>
    <button id="btnPay">Payer avec SPC</button>
  </section>

  <div id="logContainer">
    <details>
      <summary>Afficher le log</summary>
      <pre id="log"></pre>
    </details>
  </div>

  <script>
    const logEl = document.getElementById('log');
    function log(msg) { logEl.textContent += msg + '\n'; }

    let credentialId, publicKeyJwk;

    // Phase d'enrôlement
    document.getElementById('btnEnrol').onclick = async () => {
      // Options simulées du serveur (challenge, rp, user, etc.)
      const publicKey = {
        challenge: Uint8Array.from('demo-challenge', c => c.charCodeAt(0)),
        rp: { name: 'Demo SPC Bank' },
        user: {
          id: Uint8Array.from('demo-user', c=>c.charCodeAt(0)),
          name: 'user@example.com',
          displayName: 'Demo User'
        },
        pubKeyCredParams: [ { type: 'public-key', alg: -7 } ],
        authenticatorSelection: { userVerification: 'required', residentKey: 'required' },
        timeout: 60000,
        extensions: { payment: { isPayment: true } }
      };
      log('Options enrôlement:\n' + JSON.stringify(publicKey, null, 2));
      try {
        const cred = await navigator.credentials.create({ publicKey });
        // Récupération des éléments à envoyer au serveur
        credentialId = new Uint8Array(cred.rawId);
        const attObj = new Uint8Array(cred.response.attestationObject);
        const clientData = new Uint8Array(cred.response.clientDataJSON);
        // Pour la démo, on extrait la clef publique du JWK (simulé ici)
        publicKeyJwk = { kty: 'EC', crv: 'P-256', x: '...', y: '...' };
        log('credentialId (base64): ' + btoa(String.fromCharCode(...credentialId)));
        log('attestationObject (base64): ' + btoa(String.fromCharCode(...attObj)));
        log('clientDataJSON: ' + new TextDecoder().decode(clientData));
      } catch (err) {
        log('Erreur enrôlement: ' + err);
      }
    };

    // Vérification de la disponibilité SPC
    document.getElementById('btnCheck').onclick = async () => {
      if (!credentialId) { log('Veuillez d\u00e9j\u00e0 enrôler un dispositif.'); return; }
      const methodData = [{
        supportedMethods: 'secure-payment-confirmation',
        data: {
          credentialIds: [credentialId.buffer],
          challenge: Uint8Array.from('pay-challenge', c=>c.charCodeAt(0)),
          instrument: { displayName: 'Demo Card ****1234', icon: '' },
          payeeOrigin: location.origin,
          timeout: 60000
        }
      }];
      const details = { total: { label: 'Total', amount: { currency: 'EUR', value: '10.00' } } };
      const request = new PaymentRequest(methodData, details);
      try {
        const can = await request.canMakePayment();
        log('canMakePayment: ' + can);
      } catch (err) {
        log('Erreur canMakePayment: ' + err);
      }
    };

    // Phase de paiement SPC
    document.getElementById('btnPay').onclick = async () => {
      if (!credentialId) { log('Veuillez d\u00e9j\u00e0 enr\u00f4ler un dispositif.'); return; }
      const methodData = [{
        supportedMethods: 'secure-payment-confirmation',
        data: {
          credentialIds: [credentialId.buffer],
          challenge: Uint8Array.from('pay-challenge', c=>c.charCodeAt(0)),
          instrument: { displayName: 'Demo Card ****1234', icon: '' },
          payeeOrigin: location.origin,
          timeout: 60000
        }
      }];
      const details = { total: { label: 'Total', amount: { currency: 'EUR', value: '10.00' } } };
      const request = new PaymentRequest(methodData, details);
      try {
        const response = await request.show();
        log('PaymentResponse.methodName: ' + response.methodName);
        log('Response.details (PublicKeyCredential): ' + JSON.stringify(response.details));
        await response.complete('success');

        // Vérification côté serveur (exemple JS)
        log('\n-- Vérification serveur (exemple) --');
        // 1. import publicKeyJwk
        const spki = await window.crypto.subtle.importKey(
          'jwk', publicKeyJwk,
          { name: 'ECDSA', namedCurve: 'P-256' }, false, ['verify']
        );
        // 2. calcul du hash du clientDataJSON
        const cData = Uint8Array.from(atob(response.details.clientDataJSON), c=>c.charCodeAt(0));
        const hash = await window.crypto.subtle.digest('SHA-256', cData);
        // 3. vérification de la signature
        const sig = Uint8Array.from(atob(response.details.signature), c=>c.charCodeAt(0));
        const valid = await window.crypto.subtle.verify({ name: 'ECDSA', hash: 'SHA-256' }, spki, sig, hash);
        log('Signature valide: ' + valid);
      } catch (err) {
        log('Erreur paiement: ' + err);
      }
    };
  </script>
</body>
</html>
