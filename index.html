<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Démo SPC Payment Request</title>
  <style>
    body { font-family: sans-serif; padding: 1em; }
    h1, h2 { color: #333; }
    button { padding: 0.5em 1em; margin: 0.5em 0; }
    #message { color: #c00; margin: 0.5em 0; }
    #logContainer details { margin-top: 1em; }
    #log { white-space: pre-wrap; background: #f9f9f9; padding: 1em; border: 1px solid #ddd; max-height: 200px; overflow-y: auto; }
  </style>
  <!-- Pour parser l'attestationObject si besoin -->
  <script src="https://cdn.jsdelivr.net/npm/cbor-web@1.3.1/cbor.min.js"></script>
</head>
<body>
  <h1>Démo Secure Payment Confirmation (SPC)</h1>
  <div id="message"></div>

  <section id="enrolment">
    <h2>Phase d'enrôlement</h2>
    <button id="btnEnrol">Enrôler le dispositif</button>
  </section>

  <section id="payment">
    <h2>Phase de paiement</h2>
    <button id="btnCheck">Vérifier la possibilité SPC</button>
    <button id="btnPay">Payer avec SPC</button>
  </section>

  <div id="logContainer">
    <details>
      <summary>Afficher le log</summary>
      <pre id="log"></pre>
    </details>
  </div>

  <script>
    const logEl = document.getElementById('log');
    const msgEl = document.getElementById('message');
    function log(msg) { logEl.textContent += msg + '\n'; }
    function showMessage(msg) {
      msgEl.textContent = msg;
      setTimeout(() => msgEl.textContent = '', 5000);
    }

    let credentialId, publicKeyJwk;

    // Parser d'exemple pour extraire publicKeyJwk (nécessite CBOR et conversion COSE→JWK côté client ou serveur)
    function extractPublicKeyJwk(attestationObject) {
      try {
        const att = CBOR.decode(attestationObject);
        const authData = new Uint8Array(att.authData);
        // Skip headers: rpIdHash(32)+flags(1)+signCount(4)+aaguid(16)+credIdLen(2)
        const offset = 32 + 1 + 4 + 16 + 2;
        const coseKey = authData.slice(offset);
        // Ici on renvoie brute la clé COSE pour démo; serveur peut convertir en JWK
        return { coseKey: btoa(String.fromCharCode(...coseKey)) };
      } catch (e) {
        return { error: 'Parsing attestationObject failed' };
      }
    }

    // Phase d'enrôlement
    document.getElementById('btnEnrol').onclick = async () => {
      showMessage('Enrôlement en cours…');
      const publicKey = {
        challenge: Uint8Array.from('demo-challenge', c => c.charCodeAt(0)),
        rp: { name: 'Demo SPC Bank' },
        user: {
          id: Uint8Array.from('demo-user', c => c.charCodeAt(0)),
          name: 'user@example.com', displayName: 'Demo User'
        },
        pubKeyCredParams: [{ type: 'public-key', alg: -7 }],
        authenticatorSelection: { authenticatorAttachment: 'platform', userVerification: 'required', residentKey: 'required' },
        timeout: 60000,
        extensions: { payment: { isPayment: true } }
      };
      log('=== ENRÔLEMENT ===');
      log('Options publicKey:\n' + JSON.stringify({
        challenge: 'demo-challenge', rp: publicKey.rp, user: { id: 'demo-user', name: publicKey.user.name },
        authenticatorSelection: publicKey.authenticatorSelection, extensions: publicKey.extensions }, null, 2));
      try {
        const cred = await navigator.credentials.create({ publicKey });
        // Extraction et logs MDN (PublicKeyCredential) ([developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential?utm_source=chatgpt.com))
        credentialId = new Uint8Array(cred.rawId);
        log('credential.id: ' + cred.id);
        log('credential.type: ' + cred.type);
        log('rawId (base64): ' + btoa(String.fromCharCode(...credentialId)));
        const ext = cred.getClientExtensionResults();
        log('getClientExtensionResults: ' + JSON.stringify(ext));
        const attBuf = new Uint8Array(cred.response.attestationObject);
        const clientBuf = new Uint8Array(cred.response.clientDataJSON);
        log('attestationObject (base64): ' + btoa(String.fromCharCode(...attBuf)));
        log('clientDataJSON: ' + new TextDecoder().decode(clientBuf));
        // Extraction clé publique brute (COSE) pour démo
        publicKeyJwk = extractPublicKeyJwk(cred.response.attestationObject);
        log('publicKey (COSE base64): ' + publicKeyJwk.coseKey);
        showMessage('Enrôlement réussi');
      } catch (err) {
        log('Erreur enrôlement: ' + err);
        showMessage('Erreur enrôlement: ' + err.message);
      }
    };

    // Vérification et paiement SPC (MDN ([developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API/Using_secure_payment_confirmation)))
    document.getElementById('btnCheck').onclick = async () => {
      if (!credentialId) { log('Veuillez déjà enrôler un dispositif.'); showMessage('Enrôlement requis'); return; }
      const methodData = [{
        supportedMethods: 'secure-payment-confirmation', data: {
          credentialIds: [credentialId.buffer],
          challenge: Uint8Array.from('pay-challenge', c => c.charCodeAt(0)),
          rpId: location.hostname,
          payeeOrigin: location.origin,
          instrument: { displayName: 'Demo Card ****1234' },
          timeout: 60000
        }
      }];
      const details = { total: { label: 'Total', amount: { currency: 'EUR', value: '10.00' } } };
      log('\n=== VERIF SPC ===');
      try {
        const request = new PaymentRequest(methodData, details);
        const can = await request.canMakePayment();
        log('canMakePayment: ' + can);
        showMessage(can ? 'SPC disponible' : 'SPC non disponible');
      } catch (err) {
        log('Erreur canMakePayment: ' + err);
        showMessage('Vérification SPC échouée: ' + err.message);
      }
    };

    document.getElementById('btnPay').onclick = async () => {
      if (!credentialId) { log('Veuillez déjà enrôler un dispositif.'); showMessage('Enrôlement requis'); return; }
      const methodData = [{
        supportedMethods: 'secure-payment-confirmation', data: {
          credentialIds: [credentialId.buffer],
          challenge: Uint8Array.from('pay-challenge', c => c.charCodeAt(0)),
          rpId: location.hostname,
          payeeOrigin: location.origin,
          instrument: { displayName: 'Demo Card ****1234' },
          timeout: 60000
        }
      }];
      const details = { total: { label: 'Total', amount: { currency: 'EUR', value: '10.00' } } };
      log('\n=== PAIEMENT SPC ===');
      try {
        const request = new PaymentRequest(methodData, details);
        const response = await request.show();
        // Extraction détails MDN PublicKeyCredentialAssertionResponse ([developer.mozilla.org](https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API/Using_secure_payment_confirmation))
        const pkResp = response.details;
        log('methodName: ' + response.methodName);
        log('details.id: ' + pkResp.id);
        const rawIdBuf = new Uint8Array(pkResp.rawId);
        log('rawId (base64): ' + btoa(String.fromCharCode(...rawIdBuf)));
        const authData = new Uint8Array(pkResp.response.authenticatorData);
        const clientData = new Uint8Array(pkResp.response.clientDataJSON);
        const sig = new Uint8Array(pkResp.response.signature);
        const userHandle = pkResp.response.userHandle ? new Uint8Array(pkResp.response.userHandle) : null;
        log('authenticatorData (base64): ' + btoa(String.fromCharCode(...authData)));
        log('clientDataJSON: ' + new TextDecoder().decode(clientData));
        log('signature (base64): ' + btoa(String.fromCharCode(...sig)));
        if (userHandle) log('userHandle (base64): ' + btoa(String.fromCharCode(...userHandle)));
        await response.complete('success');
        showMessage('Paiement réussi');
      } catch (err) {
        log('Erreur paiement: ' + err);
        showMessage('Erreur paiement: ' + err.message);
      }
    };
  </script>
</body>
</html>
